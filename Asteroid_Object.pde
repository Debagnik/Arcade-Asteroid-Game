public class Asteroid {
  // The Default class of the Asteroids
  PVector position;
  PVector velocity;
  float radius;

  //Variables for asteroids "Jaggedness" and "Rockiness"
  int totalPoints;
  float[] offset;
  float mass; //Scaler Quantity, find explanation below comment

  //Default constructor of the asterroids
  public Asteroid() {
    //Spawns at a random location
    position = new PVector(random(width), random(height));

    //gives a random speed and direction | PVector.random2D() gives a vector of length 1 pointing in a random direction
    velocity = PVector.random2D();
    velocity.mult(random(1, 3));

    // Set a random size
    radius = random(15, 30);

    //Set the random jaggedness and rockiness by picking a random points (between 5 and 15) around the asteroid to turn the ellipse into a polygon
    totalPoints = floor(random(5, 15));
    //Then Offset array to store the random offset for each point by pushing in and pulling in the polygon vertexes
    offset = new float[totalPoints];

    //create unique jaggedness
    for (int i = 0; i < totalPoints; i++) {
      //Offset each point the radius by -5 to +5 pixels for each point
      offset[i] = random(-radius * 0.5, radius * 0.5);
    }

    /* A bit of physics and assumption on my end,
    *  I will impliment collision between asteroids, although it was not a part of the original classic game,
    *  Assumption: (I do not agree to change this). The density of all the in-game spawned asteroids will be same so the mass of the each asteroid will be based off the area of the initial circle ie. PI * radius ^ 2;
    *  In this case I will use just raduis ^ 2 to ease calculation of the masses and PI is a constant anyways and will get cancelled eventually
    *  I will use the following equation generated by an LLM (GPT + GEMMA) for conservation of momentum.
    *  _____________________________________________________________________________________________
    *  |  v1_new = v1 - [ (2 * m2) / (m1 + m2) ] * [ dot(v1-v2, p1-p2) / magSq(p1-p2) ] * (p1-p2)  |
    *  |___________________________________________________________________________________________|
    *  v1/v2: are velocity vectors
    *  p1/p2: Position Vectors
    *  m1/m2: Mass (Scaler quantity, based of area)
    *  Raw Latex format if needed: \vec{v}_1' = \vec{v}_1 - \frac{2m_2}{m_1 + m_2} \frac{(\vec{v}_1 - \vec{v}_2) \cdot (\vec{p}_1 - \vec{p}_2)}{||\vec{p}_1 - \vec{p}_2||^2} (\vec{p}_1 - \vec{p}_2)
    */
    mass = radius * radius;


  }

  // Asteroid Movement Animation
  public void update() {
    //updates position wrt velocity for movement
    position.add(velocity);

    //Arcade Style Screen Wrapping logic
    if (position.x > width + radius) position.x = -radius;
    if (position.x < -radius) position.x = width + radius;
    if (position.y > height + radius) position.y = -radius;
    if (position.y < -radius) position.y = height + radius;
  }

  public void display() {
    pushStyle();      //Isolate Style to not affect other game objects
    noFill();         //Shows just the wireframe for the classic arcade style
    stroke(255);      //Just white lines on the the wires
    strokeWeight(2);  //the whitelines boldness

    //Draw the asteroid as a polygon with random offsets for jaggedness
    pushMatrix();
    translate(position.x, position.y);

    // Draw an asteroid
    //connecting the dots
    createUniqueShape();

    //ellipse(position.x, position.y, radius*2, radius*2);
    popMatrix();// Restore coordinate system
    popStyle();
  }

  //draws jagged and rocky shapes for asteroids
  private void createUniqueShape() {
    beginShape();
    for(int i=0; i < totalPoints; i++){
      //Calculate the angle for the specific vertex
      //map() converts vertex i to an angle (0 - 2*PI)
      float angle = map(i, 0, totalPoints, 0, AsteroidConstants.TWO_PI);
      float r = radius + offset[i];

      float x = polarToCartesian(r, angle, AsteroidConstants.TrigonometricFunctionEnum.COSINE);
      float y = polarToCartesian(r, angle, AsteroidConstants.TrigonometricFunctionEnum.SINE);

      vertex(x, y);

    }
    endShape(CLOSE);
  }

  // converts polar coordinates to cartesian coordinates.
  private float polarToCartesian(final float r, final float angle, final AsteroidConstants.TrigonometricFunctionEnum function){
    switch(function){
      case SINE:
        return r * sin(angle);
      case COSINE:
        return r * cos(angle);
      case TANGENT:
        return r * tan(angle);
      default:
        return 1.0;
    }
  }

  
    /**
   * Checks collision with another asteroid and applies physics response.
   * This handles both the velocity change (Conservation of Momentum) 
   * and position correction (preventing sticking).
   */
    public void checkCollision(Asteroid other){

      //Get the pointing vector from 'other' to this 'this'
      PVector collisionVector = PVector.sub(this.position, other.position);

      // Calculate distance between centers
      float distance = collisionVector.mag();

      // Calculate minimum distance needed to not overlap
      float minDist = this.radius + other.radius;

      //collision detection logic
      if(distance < minDist){
        /* Position Correction Mechanism,
        *  Pushes the two asteroids apart so they don't get glued together in the next frame
        *  Moves them apart along the collistion angle. creating a bouncing effect
        */
        float overlap = minDist - distance;
        PVector correction = collisionVector.copy(); //get direction;
        correction.normalize();
        correction.mult(overlap/2.0); // moves each asteroids half the overlap distance.


        this.position.add(correction);  //Moves this asteroid in a way
        other.position.sub(correction); //Moves the other asteroids the other(opposite) way


        /* Collision Resolution the Physics
        *  Used the above mentioned elastic collision:
        */

        //temp copy
        PVector v1 = this.velocity;
        PVector v2 = other.velocity;
        PVector p1 = this.position;
        PVector p2 = other.position;
        float m1 = this.mass;
        float m2 = other.mass;

        //applying the velocity formula
        PVector vDiff = PVector.sub(v1, v2);
        PVector pDiff = PVector.sub(p1, p2);

        //Dot product
        float dotProduct = vDiff.dot(pDiff);

        // Distance Squared.
        float distSq = pDiff.magSq();

        //prevents division by zero case
        if(distSq == 0){
          return;
        } else {
          //calculate the scalar part of the equation:
          float scalar1 = (((2 * m2)/(m1 + m2)) * (dotProduct / distSq));
          float scalar2 = (((2 * m1)/(m1 + m2)) * (dotProduct / distSq));
          //Calculate the final Vectors to substact
          PVector v1_delta = PVector.mult(pDiff, scalar1);
          PVector v2_delta = PVector.mult(pDiff, scalar2);

          // Applying the sub: v1_new = v1_new = v - delta
          this.velocity.sub(v1_delta);

          // For the other asteroid (Symmetric math logic):
          // Because we calculated vDiff as (v1-v2) and pDiff as (p1-p2), 
          // we add the delta to v2 to conserve momentum correctly in this vector implementation
          other.velocity.add(v2_delta);
        }
      }
    }

}

