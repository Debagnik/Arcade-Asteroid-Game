public class Asteroid {
  // The Default class of the Asteroids
  PVector position;
  PVector velocity;
  float radius;

  //Variables for asteroids "Jaggedness" and "Rockiness"
  int totalPoints;
  float[] offset;
  float mass; //Scaler Quantity, find explanation below comment

  //Default constructor of the asterroids
  public Asteroid() {
    //Spawns at a random location
    position = new PVector(random(width), random(height));

    //gives a random speed and direction | PVector.random2D() gives a vector of length 1 pointing in a random direction
    velocity = PVector.random2D();
    velocity.mult(random(1, 3));

    // Set a random size
    radius = random(15, 30);

    //Set the random jaggedness and rockiness by picking a random points (between 5 and 15) around the asteroid to turn the ellipse into a polygon
    totalPoints = floor(random(5, 15));
    //Then Offset array to store the random offset for each point by pushing in and pulling in the polygon vertexes
    offset = new float[totalPoints];

    //create unique jaggedness
    for (int i = 0; i < totalPoints; i++) {
      //Offset each point the radius by -5 to +5 pixels for each point
      offset[i] = random(-radius * 0.5, radius * 0.5);
    }

    /* A bit of physics and assumption on my end,
    *  I will impliment collision between asteroids, although it was not a part of the original classic game,
    *  Assumption: (I do not agree to change this). The density of all the in-game spawned asteroids will be same so the mass of the each asteroid will be based off the area of the initial circle ie. PI * radius ^ 2;
    *  In this case I will use just raduis ^ 2 to ease calculation of the masses and PI is a constant anyways and will get cancelled eventually
    *  I will use the following equation generated by an LLM (GPT + GEMMA) for conservation of momentum.
    *  _____________________________________________________________________________________________
    *  |  v1_new = v1 - [ (2 * m2) / (m1 + m2) ] * [ dot(v1-v2, p1-p2) / magSq(p1-p2) ] * (p1-p2)  |
    *  |___________________________________________________________________________________________|
    *  v1/v2: are velocity vectors
    *  p1/p2: Position Vectors
    *  m1/m2: Mass (Scaler quantity, based of area)
    *  Raw Latex format if needed: \vec{v}_1' = \vec{v}_1 - \frac{2m_2}{m_1 + m_2} \frac{(\vec{v}_1 - \vec{v}_2) \cdot (\vec{p}_1 - \vec{p}_2)}{||\vec{p}_1 - \vec{p}_2||^2} (\vec{p}_1 - \vec{p}_2)
    */
    mass = radius * radius;


  }

  // Asteroid Movement Animation
  public void update() {
    //updates position wrt velocity for movement
    position.add(velocity);

    //Arcade Style Screen Wrapping logic
    if (position.x > width + radius) position.x = -radius;
    if (position.x < -radius) position.x = width + radius;
    if (position.y > height + radius) position.y = -radius;
    if (position.y < -radius) position.y = height + radius;
  }

  public void display() {
    pushStyle();      //Isolate Style to not affect other game objects
    noFill();         //Shows just the wireframe for the classic arcade style
    stroke(255);      //Just white lines on the the wires
    strokeWeight(2);  //the whitelines boldness

    //Draw the asteroid as a polygon with random offsets for jaggedness
    pushMatrix();
    translate(position.x, position.y);

    // Draw an asteroid
    //connecting the dots
    createUniqueShape();

    //ellipse(position.x, position.y, radius*2, radius*2);
    popMatrix();// Restore coordinate system
    popStyle();
  }

  //draws jagged and rocky shapes for asteroids
  private void createUniqueShape() {
    beginShape();
    for(int i=0; i < totalPoints; i++){
      //Calculate the angle for the specific vertex
      //map() converts vertex i to an angle (0 - 2*PI)
      float angle = map(i, 0, totalPoints, 0, AsteroidConstants.TWO_PI);
      float r = radius + offset[i];

      float x = polarToCartesian(r, angle, AsteroidConstants.TRIGNOMETRIC_FUNCTIONS_ENUM.COSINE);
      float y = polarToCartesian(r, angle, AsteroidConstants.TRIGNOMETRIC_FUNCTIONS_ENUM.SINE);

      vertex(x, y);

    }
    endShape(CLOSE);
  }

  // converts polar coordinates to cartesian coordinates.
  private float polarToCartesian(final float r, final float angle, final AsteroidConstants.TRIGNOMETRIC_FUNCTIONS_ENUM function){
    switch(function){
      case SINE:
        return r * sin(angle);
      case COSINE:
        return r * cos(angle);
      case TANGENT:
        return r * tan(angle);
      default:
        return 1.0;
    }
  }





}

