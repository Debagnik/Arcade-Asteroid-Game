public static class PhysicsHelper {
    /**
      * Handles Arcade-style screen wrapping.
      * Checks if an object has gone off-screen and wraps it to the other side.
    */
    public static void screenWrap(PVector position, float radius, float width, float height){
        if (position.x > width + radius) position.x = -radius;
        if (position.x < -radius) position.x = width + radius;
        if (position.y > height + radius) position.y = -radius;
        if (position.y < -radius) position.y = height + radius;
    }

    /**
     * Converts Polar coordinates (r, angle) to Cartesian (x, y).
    */
    public static float polarToCartesian(final float r, final float angle, final AsteroidConstants.TrigonometricFunctionEnum function){
    switch(function){
      case SINE:
        return r * sin(angle);
      case COSINE:
        return r * cos(angle);
      case TANGENT:
        return r * tan(angle);
      default:
        throw new IllegalArgumentException("Unsupported trigonometric function: " + function);
    }
  }


  /* A bit of physics and assumption on my end,
    *  I will impliment collision between asteroids, although it was not a part of the original classic game,
    *  Assumption: (I do not agree to change this). The density of all the in-game spawned asteroids will be same so the mass of the each asteroid will be based off the area of the initial circle ie. PI * radius ^ 2;
    *  In this case I will use just raduis ^ 2 to ease calculation of the masses and PI is a constant anyways and will get cancelled eventually
    *  I will use the following equation generated by an LLM (GPT + GEMMA) for conservation of momentum.
    *  _____________________________________________________________________________________________
    *  |  v1_new = v1 - [ (2 * m2) / (m1 + m2) ] * [ dot(v1-v2, p1-p2) / magSq(p1-p2) ] * (p1-p2)  |
    *  |___________________________________________________________________________________________|
    *  v1/v2: are velocity vectors
    *  p1/p2: Position Vectors
    *  m1/m2: Mass (Scaler quantity, based of area)
    *  Raw Latex format if needed: \vec{v}_1' = \vec{v}_1 - \frac{2m_2}{m_1 + m_2} \frac{(\vec{v}_1 - \vec{v}_2) \cdot (\vec{p}_1 - \vec{p}_2)}{||\vec{p}_1 - \vec{p}_2||^2} (\vec{p}_1 - \vec{p}_2)
   */

  /**
   * Checks collision with another asteroid and applies physics response.
   * This handles both the velocity change (Conservation of Momentum) 
   * and position correction (preventing sticking).
   */
  public static void checkCollision(Asteroid thisOne, Asteroid other){

      //Get the pointing vector from 'other' to thisOne 'thisOne'
      PVector collisionVector = PVector.sub(thisOne.position, other.position);

      // Calculate distance between centers
      float distance = collisionVector.mag();

      // Calculate minimum distance needed to not overlap
      float minDist = thisOne.radius + other.radius;

      //collision detection logic
      if(distance < minDist){
        /* Position Correction Mechanism,
        *  Pushes the two asteroids apart so they don't get glued together in the next frame
        *  Moves them apart along the collision angle, creating a bouncing effect
        */
        float overlap = minDist - distance;
        PVector correction = collisionVector.copy(); //get direction;
        
        // NaN PREVENTION
        if (distance < 0.0001) { 
            // If they are on top of each other, pick a random direction to push them apart
            correction = PVector.random2D(); 
        } else {
            correction.normalize();
        }

        correction.mult(overlap/2.0); // moves each asteroids half the overlap distance.


        thisOne.position.add(correction);  //Moves thisOne asteroid in a way
        other.position.sub(correction); //Moves the other asteroids the other(opposite) way


        /* Collision Resolution the Physics
        *  Used the above mentioned elastic collision:
        */

        //temp copy
        PVector v1 = thisOne.velocity.copy();
        PVector v2 = other.velocity.copy();
        PVector p1 = thisOne.position.copy();
        PVector p2 = other.position.copy();
        float m1 = thisOne.mass;
        float m2 = other.mass;

        //applying the velocity formula
        PVector vDiff = PVector.sub(v1, v2);
        PVector pDiff = PVector.sub(p1, p2);

        //Dot product
        float dotProduct = vDiff.dot(pDiff);
        // Skip response if asteroids are already separating
        if (dotProduct > 0) {
          return;
        }

        // Distance Squared.
        float distSq = pDiff.magSq();

        //prevents division by zero case
        if(distSq < 0.0001){ // Small epsilon to handle floating-point precision
          return;
        } else {
          //calculate the scalar part of the equation:
          float scalar1 = (((2 * m2)/(m1 + m2)) * (dotProduct / distSq));
          float scalar2 = (((2 * m1)/(m1 + m2)) * (dotProduct / distSq));
          //Calculate the final Vectors to subtract
          PVector v1_delta = PVector.mult(pDiff, scalar1);
          PVector v2_delta = PVector.mult(pDiff, scalar2);

          // Applying the sub: v1_new = v - delta
          thisOne.velocity.sub(v1_delta);

          // For the other asteroid (Symmetric math logic):
          // Because we calculated vDiff as (v1-v2) and pDiff as (p1-p2), 
          // we add the delta to v2 to conserve momentum correctly in thisOne vector implementation
          other.velocity.add(v2_delta);
        }
      }
    }


}