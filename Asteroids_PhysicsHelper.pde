/*
 * Asteroids Game
 * License DWTFYWTPL <https://www.wtfpl.net/about/>
 * Copyright 2025 Rak Kingabed <debagnik@debagnik.in>
 * FILE: Asteroids_PhysicsHelper.pde
 */

public static class PhysicsHelper {
    /**
      * Handles Arcade-style screen wrapping.
      * Checks if an object has gone off-screen and wraps it to the other side.
    */
    public static void screenWrap(PVector position, float radius, float width, float height){
        if (position.x > width + radius) position.x = -radius;
        if (position.x < -radius) position.x = width + radius;
        if (position.y > height + radius) position.y = -radius;
        if (position.y < -radius) position.y = height + radius;
    }

    /**
     * Converts Polar coordinates (r, angle) to Cartesian (x, y).
    */
    public static float polarToCartesian(final float r, final float angle, final AsteroidConstants.TrigonometricFunctionEnum function){
    switch(function){
      case SINE:
        return r * sin(angle);
      case COSINE:
        return r * cos(angle);
      case TANGENT:
        return r * tan(angle);
      default:
        throw new IllegalArgumentException("Unsupported trigonometric function: " + function);
    }
  }


  /* A bit of physics and assumption on my end,
    *  I will impliment collision between asteroids, although it was not a part of the original classic game,
    *  Assumption: (I do not agree to change this). The density of all the in-game spawned asteroids will be same so the mass of the each asteroid will be based off the area of the initial circle ie. PI * radius ^ 2;
    *  In this case I will use just raduis ^ 2 to ease calculation of the masses and PI is a constant anyways and will get cancelled eventually
    *  I will use the following equation generated by an LLM (GPT + GEMMA) for conservation of momentum.
    *  _____________________________________________________________________________________________
    *  |  v1_new = v1 - [ (2 * m2) / (m1 + m2) ] * [ dot(v1-v2, p1-p2) / magSq(p1-p2) ] * (p1-p2)  |
    *  |___________________________________________________________________________________________|
    *  v1/v2: are velocity vectors
    *  p1/p2: Position Vectors
    *  m1/m2: Mass (Scaler quantity, based of area)
    *  Raw Latex format if needed: \vec{v}_1' = \vec{v}_1 - \frac{2m_2}{m_1 + m_2} \frac{(\vec{v}_1 - \vec{v}_2) \cdot (\vec{p}_1 - \vec{p}_2)}{||\vec{p}_1 - \vec{p}_2||^2} (\vec{p}_1 - \vec{p}_2)
   */

  /**
   * Checks collision with another asteroid and applies physics response.
   * This handles both the velocity change (Conservation of Momentum) 
   * and position correction (preventing sticking).
   */
  public static void checkCollision(Asteroid thisOne, Asteroid other){

      //Get the pointing vector from 'other' to thisOne 'thisOne'
      PVector collisionVector = PVector.sub(thisOne.getPosition(), other.getPosition());

      // Calculate distance between centers
      float distance = collisionVector.mag();

      // Calculate minimum distance needed to not overlap
      float minDist = thisOne.getRadius() + other.getRadius();

      //collision detection logic
      if(distance < minDist){
        /* Position Correction Mechanism,
        *  Pushes the two asteroids apart so they don't get glued together in the next frame
        *  Moves them apart along the collision angle, creating a bouncing effect
        */
        float overlap = minDist - distance;
        PVector correction = collisionVector.copy(); //get direction;
        
        // NaN PREVENTION
        if (distance < 0.0001) { 
            // If they are on top of each other, pick a random direction to push them apart
            correction = PVector.random2D(); 
        } else {
            correction.normalize();
        }

        correction.mult(overlap/2.0); // moves each asteroids half the overlap distance.

        // Position Correction
        PVector p1 = thisOne.getPosition();
        PVector p2 = other.getPosition();
        thisOne.setPosition(p1.add(correction));  //Moves thisOne asteroid in a way
        other.setPosition(p2.sub(correction)); //Moves the other asteroids the other(opposite) way


        /* Collision Resolution the Physics
        *  Used the above mentioned elastic collision:
        */

        // Velocity Correction
        PVector v1 = thisOne.getVelocity();
        PVector v2 = other.getVelocity();
        float m1 = thisOne.getMass();
        float m2 = other.getMass();

        //applying the velocity formula
        PVector vDiff = PVector.sub(v1, v2);
        PVector pDiff = PVector.sub(thisOne.getPosition(), other.getPosition());

        //Dot product
        float dotProduct = vDiff.dot(pDiff);
        // Skip response if asteroids are already separating
        if (dotProduct > 0) {
          return;
        }

        // Distance Squared.
        float distSq = pDiff.magSq();

        //prevents division by zero case
        if(distSq < 0.0001){ // Small epsilon to handle floating-point precision
          return;
        } else {
          //calculate the scalar part of the equation:
          float scalar1 = (((2 * m2)/(m1 + m2)) * (dotProduct / distSq));
          float scalar2 = (((2 * m1)/(m1 + m2)) * (dotProduct / distSq));
          //Calculate the final Vectors to subtract
          PVector v1_delta = PVector.mult(pDiff, scalar1);
          PVector v2_delta = PVector.mult(pDiff, scalar2);

          // Applying the sub: v1_new = v - delta
          v1.sub(v1_delta);
          thisOne.setVelocity(v1);

          // For the other asteroid (Symmetric math logic):
          // Because we calculated vDiff as (v1-v2) and pDiff as (p1-p2), 
          // we add the delta to v2 to conserve momentum correctly in thisOne vector implementation
          v2.add(v2_delta);
          other.setVelocity(v2);
        }
      }
    }

    /* Laser to Asteroid Collision Mechanics
     * Checks if a laser has hit an asteroid.
     * Simple Distance check: Dist < Radius
     */
    public static boolean checkLaserCollision(Laser l, Asteroid a){
      float dist = PVector.dist(l.getPosition(), a.getPosition());
      if(dist < a.getRadius() + AsteroidConstants.LASER_SIZE / 2.0){
        return true;
      }
      return false;
    }

    /* Ship to Asteroid Collision mechanics
     * Checks if the ship is Invincible ie. Game mode is either TEST/DEBUG or the player ship was recently destroyed
     * Checks if the player ship hit an asteroid
     * Simple check: Dist < Radius
     */
    public static boolean checkShip2AsteroidCollision(Spacecraft ship, Asteroid a){
      if(ship.isInvincible()){
        return false;
      }
      float dist = PVector.dist(ship.getPosition(), a.getPosition());
      if(dist < a.getRadius() + AsteroidConstants.SHIP_SIZE){
        return true;
      }
      return false;
    }

    public static PVector avoidAsteroidForUFO(final PVector ufoPos, final ArrayList<Asteroid> asteroids){
      PVector avoidance = new PVector(0, 0);
      int c = 0;

      for(Asteroid a : asteroids){
        final float dist = PVector.dist(ufoPos, a.getPosition());
        // points vector away from asteroids
        if(dist < AsteroidConstants.UFO_AVOIDANCE_RADIUS && dist > 0.0001){
          PVector diff = PVector.sub(ufoPos, a.getPosition());
          diff.normalize();
          // Weight by distance (closer = stronger push)
          diff.div(dist);
          avoidance.add(diff);
          c++; //HEHE C++ reference in a Processing (JAVA) code.
        }
      }

      if(c > 0){
        // Maximise avoidance force by a factor of 2
        avoidance.div(c);
        avoidance.normalize();
        avoidance.mult(2.0);
      }

      return avoidance;

    }

    public static boolean checkPlayerLaser2UFOCollision(PlayerLaser pl, UFO ufo) {
      float dist = PVector.dist(pl.getPosition(), ufo.getPosition());

      return dist < (ufo.getRadius() + (AsteroidConstants.LASER_SIZE / 2.0));
    }


}